%include "hashmap.hz"
%include "dynarray.hz"
%include "string.hz"
%include "token.hz"
%include "cstdlib.hz"
%include "ctype.hz"

local proc ishzalpha(c: i32) -> u8 {
    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_';
}

local proc ishzalnum(c: i32) -> u8 {
    return ishzalpha(c) || isdigit(c);
}


local proc hzsubstring(str: u8*, start: u32, end: u32) -> u8* {
    var size: u32 = end - start;
    var new_str: u8* = malloc(size + 1);
    new_str[size] = 0; // null terminator
    memcpy(new_str, (ptr)str + start, size);
    return new_str;
}


class HzScanner {
    var source: u8*;
    var source_len: u32;
    var pos: u32;
    var start: u32;
    var keywords: HashMap;
    var tokens: DynArray;
    var location: struct {
        file: u8*;
        row: u32;
        col: u32;
    };

    proc scan(source: u8*, file: u8*) -> DynArray {
        this.source = source;
        this.source_len = strlen(source);
        this.tokens = new DynArray;
        this.pos = 0;
        this.location.file = file;
        this.location.row = 1;
        this.location.col = 1;
        this.initialize_kw();

        while(this.available()) {
            this.start = this.pos;
            this.scan_token();
            this.location.col = this.location.col + (this.pos - this.start);
        }

        this.add_token(TokenType.EOF, NULL, 0);
        return this.tokens;
    }

    proc scan_token {
        var c = this.advance();

        switch(c) {
            case '+': this.add_token(TokenType.PLUS, NULL, 0); break;
            case '-':
                if(this.match('>')) {
                    this.add_token(TokenType.POINTER_ARROW, NULL, 0);
                } else {
                    this.add_token(TokenType.MINUS, NULL, 0);
                }
                break;
            case '*': this.add_token(TokenType.STAR, NULL, 0); break;
            case '|':
                if(this.match('|')) {
                    this.add_token(TokenType.OR, NULL, 0);
                } else {
                    this.add_token(TokenType.PIPE, NULL, 0);
                }
                break;
            case '^': this.add_token(TokenType.ARROW_UP, NULL, 0); break;
            case '{': this.add_token(TokenType.OPEN_BRACE, NULL, 0); break;
            case '}': this.add_token(TokenType.CLOSE_BRACE, NULL, 0); break;
            case '[': this.add_token(TokenType.OPEN_SQUARE, NULL, 0); break;
            case ']': this.add_token(TokenType.CLOSE_SQUARE, NULL, 0); break;
            case '(': this.add_token(TokenType.OPEN_PAREN, NULL, 0); break;
            case ')': this.add_token(TokenType.CLOSE_PAREN, NULL, 0); break;
            case ',': this.add_token(TokenType.COMMA, NULL, 0); break;
            case '.':
                if(this.match('.')) {
                    if(this.match('.')) {
                        this.add_token(TokenType.VARARGS, NULL, 0);
                    } else {
                        this.add_token(TokenType.DOT, NULL, 0);
                        this.add_token(TokenType.DOT, NULL, 0);
                    }
                } else {
                    this.add_token(TokenType.DOT, NULL, 0);
                }
                break;
            case ';': this.add_token(TokenType.SEMICOLON, NULL, 0); break;
            case ':': this.add_token(TokenType.COLON, NULL, 0); break;
            case '&':
                if(this.match('&')) {
                    this.add_token(TokenType.AND, NULL, 0);
                } else {
                    this.add_token(TokenType.AMPERSAND, NULL, 0);
                }
                break;
            case '=':
                if(this.match('=')) {
                    this.add_token(TokenType.DEQUALS, NULL, 0);
                } else {
                    this.add_token(TokenType.EQUALS, NULL, 0);
                }
                break;
            case '>':
                if(this.match('=')) {
                    this.add_token(TokenType.GEQUALS, NULL, 0);
                } else {
                    this.add_token(TokenType.GREATER, NULL, 0);
                }
                break;
            case '<':
                if(this.match('=')) {
                    this.add_token(TokenType.LEQUALS, NULL, 0);
                } else {
                    this.add_token(TokenType.LOWER, NULL, 0);
                }
                break;
            case '?': this.add_token(TokenType.QUESTION_MARK, NULL, 0); break;
            case '!':
                if(this.match('=')) {
                    this.add_token(TokenType.NEQUALS, NULL, 0);
                } else {
                    this.add_token(TokenType.BANG, NULL, 0);
                }
                break;
            case '%':
                if(ishzalpha(this.peek())) {
                    this.pos = this.pos + 1;
                    this.scan_macro();
                } else {
                    this.add_token(TokenType.PRECENT, NULL, 0);
                }
                break;

            case '/':
                if(this.match('/')) {
                    while(this.peek() != '\n' && this.available()) {
                        this.pos = this.pos + 1;
                    }
                } else {
                    this.add_token(TokenType.SLASH, NULL, 0);
                }
                break;

            case ' ':
            case '\r':
            case '\t':
                break;

            case '\n':
                this.location.col = 0;
                this.location.row = this.location.row + 1;
                break;

            case '"': this.scan_string(); break;
            case '\'': this.scan_char(); break;

            default:
                if(isdigit(c)) {
                    this.scan_number();
                } else if(ishzalpha(c)) {
                    this.scan_identifier();
                } else {
                    fprintf(stderr, "%s:%d:%d: [ERROR] Unexpected character '%c'", this.location.file, this.location.row, this.location.col, c);
                    exit(1);
                }
                break;
        }
    }

    proc scan_identifier {
        while(ishzalnum(this.peek())) 
            this.pos = this.pos + 1;

        var identifier = hzsubstring(this.source, this.start, this.pos);
        var keyword_id = this.keywords.get(identifier);
        var token_type: TokenType;
        
        if(keyword_id) {
            token_type = (TokenType)keyword_id;
        } else {
            token_type = TokenType.IDENTIFIER;
        }

        this.add_token(token_type, identifier, 0);
    }

    proc scan_macro {
        while(ishzalnum(this.peek())) 
            this.pos = this.pos + 1;

        var identifier = hzsubstring(this.source, this.start + 1, this.pos);
        var macro = hzsubstring(this.source, this.start, this.pos);
        
        var keyword_id = this.keywords.get(identifier);
        var macro_id = this.keywords.get(macro);
        var token_type: TokenType;
        
        if(keyword_id) {
            this.add_token(TokenType.PRECENT, NULL, 0);
            token_type = (TokenType)keyword_id;
        } else if(macro_id) {
            token_type = (TokenType)macro_id;
        } else {
            this.add_token(TokenType.PRECENT, NULL, 0);
            token_type = TokenType.IDENTIFIER;
        }

        this.add_token(token_type, identifier, 0);
    }

    proc scan_number {
        while(isdigit(this.peek()))
            this.pos = this.pos + 1;

        var number_str = hzsubstring(this.source, this.start, this.pos);
        // convert string to number
        var number = atoll(number_str);
        this.add_token(TokenType.NUMBER, NULL, number);
        free(number_str);
    }

    proc scan_string {
        while(this.peek() != '"' && this.available()) {
            if(this.peek() == '\n') {
                fprintf(stderr, "%s:%d:%d: [ERROR] New lines aren't allowed in strings", this.location.file, this.location.row, this.location.col);
                exit(1);
            }
            var c = this.advance();
            if(c == '\\') this.pos = this.pos + 1;
        }

        this.pos = this.pos + 1;

        var size: u32 = this.pos - this.start - 2;
        var str: u8* = malloc(size + 1);
        str[size] = 0;
        memcpy(str, (ptr)this.source + this.start + 1, size);

        this.add_token(TokenType.STRING, str, 0);
    }

    proc scan_char {
        if(!this.available()) {
            fprintf(stderr, "%s:%d:%d: [ERROR] Unclosed character literal", this.location.file, this.location.row, this.location.col);
            exit(1);
        }

        var char = this.advance();
        if(char == '\\') {
            var next = this.advance();
            switch(next) {
                case 'n': char = '\n'; break;
                case 'r': char = '\r'; break;
                case '0': char = '\0'; break;
                case '\\': char = '\\'; break;
                default: char = next; break;
            }
        }

        this.consume('\'');
        this.add_token(TokenType.NUMBER, NULL, char);
    }

    proc add_token(type: TokenType, value: ptr, number: u64) {
        this.tokens.append((u64)new Token(type, value, number, (TokenLocation)this.location));
    }

    proc peek -> u8 {
        if(!this.available()) return 0;
        return this.source[this.pos];
    }

    proc advance -> u8 {
        if(!this.available()) return 0;
        this.pos = this.pos + 1;
        return this.source[this.pos - 1];
    }

    proc available -> u8 {
        return this.pos < this.source_len;
    }

    proc match(expected: u8) -> u8 {
        if(!this.available()) return false;
        if(this.source[this.pos] != expected) return false;

        this.pos = this.pos + 1;
        return true;
    }

    proc consume(expected: u8) -> u8 {
        if(this.match(expected)) return this.source[this.pos - 1];

        fprintf(stderr, "%s:%d:%d: [ERROR] Expected character: %c\n", this.location.file, this.location.row, this.location.col, expected);
        exit(1);
        return 0;
    }

    proc initialize_kw {
        this.keywords = new HashMap;
        this.keywords.set("u8", TokenType.U8);
        this.keywords.set("u16", TokenType.U16);
        this.keywords.set("u32", TokenType.U32);
        this.keywords.set("u64", TokenType.U64);
        this.keywords.set("i8", TokenType.I8);
        this.keywords.set("i16", TokenType.I16);
        this.keywords.set("i32", TokenType.I32);
        this.keywords.set("i64", TokenType.I64);
        this.keywords.set("ptr", TokenType.PTR);
        this.keywords.set("proc", TokenType.PROC);
        this.keywords.set("struct", TokenType.STRUCT);
        this.keywords.set("class", TokenType.CLASS);
        this.keywords.set("enum", TokenType.ENUM);
        this.keywords.set("local", TokenType.LOCAL);
        this.keywords.set("break", TokenType.BREAK);
        this.keywords.set("external", TokenType.EXTERNAL);
        this.keywords.set("return", TokenType.RETURN);
        this.keywords.set("new", TokenType.NEW);
        this.keywords.set("true", TokenType.TRUE);
        this.keywords.set("false", TokenType.FALSE);
        this.keywords.set("while", TokenType.WHILE);
        this.keywords.set("if", TokenType.IF);
        this.keywords.set("else", TokenType.ELSE);
        this.keywords.set("var", TokenType.VAR);
        this.keywords.set("stdcall", TokenType.STDCALL);
        this.keywords.set("res", TokenType.RES);
        this.keywords.set("switch", TokenType.SWITCH);
        this.keywords.set("case", TokenType.CASE);
        this.keywords.set("default", TokenType.DEFAULT);
        this.keywords.set("asm", TokenType.ASM);
        this.keywords.set("%define", TokenType.DEFINE);
        this.keywords.set("%include", TokenType.INCLUDE);
        this.keywords.set("sizeof", TokenType.SIZEOF);
        this.keywords.set("%rsp", TokenType.REGISTER);
        this.keywords.set("%rbp", TokenType.REGISTER);
        this.keywords.set("%rax", TokenType.REGISTER);
        this.keywords.set("%rbx", TokenType.REGISTER);
        this.keywords.set("%rcx", TokenType.REGISTER);
        this.keywords.set("%rdx", TokenType.REGISTER);
        this.keywords.set("%rdi", TokenType.REGISTER);
        this.keywords.set("%rsi", TokenType.REGISTER);
        this.keywords.set("%r8", TokenType.REGISTER);
        this.keywords.set("%r9", TokenType.REGISTER);
        this.keywords.set("%r10", TokenType.REGISTER);
        this.keywords.set("%r11", TokenType.REGISTER);
        this.keywords.set("%r12", TokenType.REGISTER);
        this.keywords.set("%r13", TokenType.REGISTER);
        this.keywords.set("%r14", TokenType.REGISTER);
        this.keywords.set("%r15", TokenType.REGISTER);
        this.keywords.set("%r16", TokenType.REGISTER);
    }
}
